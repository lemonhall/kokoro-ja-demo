# 如何为 Misaki C Port 添加新语言支持

## 概述

本指南以**昆雅语（Quenya）**为例，演示如何为 Misaki C Port 系统添加一种全新的语言支持，从而实现该语言的文本到语音（TTS）功能。

昆雅语是托尔金创造的精灵语言，具有完整且规则的音系，是演示新语言扩展的理想案例。

---

## 实现步骤总览

添加新语言需要完成以下 5 个步骤：

1. **研究语言音系** - 收集权威的发音规则和音素映射
2. **创建 G2P 模块** - 实现文字到音素的转换逻辑
3. **创建分词器模块** - 实现文本分词（如适用）
4. **集成到主系统** - 修改语言检测和 API 接口
5. **测试和验证** - 编写测试用例并生成音频

---

## 第一步：研究语言音系

### 1.1 收集权威资料

找到可信的语言学资源，了解目标语言的音系规则。以昆雅语为例：

**权威资料来源：**
- https://realelvish.net/pronunciation/quenya/
- https://en.wikibooks.org/wiki/Quenya/Phonology
- https://eldamo.org/

**需要收集的信息：**
- 元音系统（短元音、长元音、双元音）
- 辅音系统（基础辅音、辅音簇、特殊发音）
- 重音规则（如何确定重音位置）
- 特殊字符（如昆雅语的 ñ, þ, 长音符 á, é 等）

### 1.2 整理音素映射表

将字母/字母组合映射到 IPA（国际音标）：

**昆雅语示例：**

| 书写形式 | IPA 音素 | 说明 |
|---------|---------|------|
| a, á | /a/, /aː/ | 短元音和长元音 |
| e, é | /ɛ/, /eː/ | |
| qu | /kw/ | 辅音簇 |
| ñ | /ŋ/ | 特殊辅音 |
| ai | /aj/ | 双元音 |

---

## 第二步：创建 G2P 模块

### 2.1 创建头文件

在 `include/` 目录下创建 `misaki_g2p_<语言代码>.h`：

**文件：** `include/misaki_g2p_qya.h`

```c
#ifndef MISAKI_G2P_QYA_H
#define MISAKI_G2P_QYA_H

#include "misaki_types.h"

// 初始化和清理函数
int misaki_g2p_qya_init(void);
void misaki_g2p_qya_cleanup(void);

// 核心转换函数
int misaki_g2p_qya_convert(const char* word, char** phonemes);

// 辅助函数
int misaki_qya_count_syllables(const char* word);
int misaki_qya_calculate_stress(const char* word);

#endif
```

### 2.2 实现 G2P 转换逻辑

在 `src/core/` 目录下创建 `misaki_g2p_<语言代码>.c`：

**关键实现要点：**

1. **定义音素映射表**（静态数组）
2. **实现字符串匹配逻辑**（按长度优先匹配）
3. **处理特殊规则**（如重音、长音、音节划分）
4. **输出 IPA 格式音素**

**代码结构示例：**

```c
// 元音映射表
static const VowelMapping SHORT_VOWELS[] = {
    {"a", "a"},
    {"e", "ɛ"},
    {"i", "i"},
    // ...
    {NULL, NULL}
};

// 长元音映射表
static const VowelMapping LONG_VOWELS[] = {
    {"á", "aː"},
    {"é", "eː"},
    // ...
    {NULL, NULL}
};

// 双元音映射表
static const VowelMapping DIPHTHONGS[] = {
    {"ai", "aj"},
    {"au", "au"},
    // ...
    {NULL, NULL}
};

// 辅音簇映射表（按长度降序排列！）
static const ConsonantMapping CONSONANT_CLUSTERS[] = {
    {"qu", "kw"},
    {"ng", "ŋɡ"},
    {"th", "θ"},
    // ...
    {NULL, NULL}
};
```

**转换函数核心逻辑：**

```c
int misaki_g2p_qya_convert(const char* word, char** phonemes) {
    char* result = malloc(...);
    const char* p = word;
    
    while (*p) {
        // 1. 检查双元音（优先级最高）
        if (match_diphthong(p, phoneme)) {
            append_phoneme(result, phoneme);
            p += len;
            continue;
        }
        
        // 2. 检查长元音
        if (match_long_vowel(p, phoneme)) {
            append_phoneme(result, phoneme);
            p += len;
            continue;
        }
        
        // 3. 检查短元音
        // 4. 检查辅音簇
        // 5. 检查单辅音
    }
    
    *phonemes = result;
    return 0;
}
```

---

## 第三步：创建分词器模块

### 3.1 评估是否需要分词器

**需要分词器的语言：**
- 中文、日文（无空格分隔）
- 需要词典匹配的语言

**不需要复杂分词器的语言：**
- 英文、昆雅语等（按空格和标点分词即可）

### 3.2 简单分词器实现

对于按空格分词的语言，创建简单分词器：

**文件：** `src/core/misaki_tokenizer_qya.c`

```c
int misaki_tokenize_qya(const char* text, MisakiToken** tokens, int* token_count) {
    // 1. 跳过空白字符
    // 2. 识别单词（连续字母）
    // 3. 识别标点符号
    // 4. 识别数字
    // 5. 输出 token 数组
}
```

---

## 第四步：集成到主系统

### 4.1 更新类型定义

在 `include/misaki_types.h` 中添加语言枚举：

```c
typedef enum {
    LANG_ENGLISH,
    LANG_CHINESE,
    LANG_JAPANESE,
    LANG_KOREAN,
    LANG_VIETNAMESE,
    LANG_QUENYA,      // 新增昆雅语
    LANG_UNKNOWN
} MisakiLanguage;
```

### 4.2 更新语言检测

在 `src/core/misaki_lang_detect.c` 中添加检测规则：

```c
// 添加特征词
static const LangFeatureWord QYA_FEATURES[] = {
    {"quenya", LANG_QUENYA, 10.0},
    {"eldar", LANG_QUENYA, 9.0},
    {"valar", LANG_QUENYA, 9.0},
    // ...
    {NULL, LANG_UNKNOWN, 0.0}
};

// 添加特殊字符检测
static bool is_quenya_special(uint32_t codepoint) {
    return (codepoint == 0x00F1 || codepoint == 0x00FE || ...);
}

// 更新语言名称
const char* misaki_language_name(MisakiLanguage lang) {
    switch (lang) {
        // ... existing cases ...
        case LANG_QUENYA: return "昆雅语";
        default: return "未知";
    }
}
```

### 4.3 更新 API 接口

在 `src/api/misaki_api.c` 中：

**1. 添加头文件引用：**

```c
#include "misaki_g2p_qya.h"
#include "misaki_tokenizer_qya.h"
```

**2. 初始化函数中添加：**

```c
int misaki_init(const char *data_dir) {
    
    // 初始化昆雅语 G2P（无需词典）
    misaki_g2p_qya_init();
    misaki_tokenizer_qya_init();
    
    return 0;
}
```

**3. 语言代码解析：**

```c
if (strcmp(lang, "qya") == 0 || strcmp(lang, "quenya") == 0) {
    detected_lang = LANG_QUENYA;
}
```

**4. G2P 处理逻辑：**

```c
case LANG_QUENYA:
    {
        // 昆雅语特殊处理：直接调用 G2P，不需要词典
        char* phonemes_str = NULL;
        if (misaki_g2p_qya_convert(text, &phonemes_str) == 0 && phonemes_str) {
            strncpy(output_buffer, phonemes_str, buffer_size - 1);
            output_buffer[buffer_size - 1] = '\0';
            free(phonemes_str);
            return 0;
        }
        return -1;
    }
    break;
```

**5. 清理函数：**

```c
void misaki_cleanup(void) {
    
    misaki_g2p_qya_cleanup();
    misaki_tokenizer_qya_cleanup();
}
```

### 4.4 更新构建配置

在 `CMakeLists.txt` 中添加新文件：

```cmake
set(MISAKI_SOURCES
    # ... existing sources ...
    ${MISAKI_SRC_DIR}/core/misaki_tokenizer_qya.c
    ${MISAKI_SRC_DIR}/core/misaki_g2p_qya.c
)
```

---

## 第五步：测试和验证

### 5.1 编写单元测试

创建 `tests/test_g2p_qya.c` 和 `tests/test_tokenizer_qya.c`：

```c
void test_case(const char* name, const char* input, const char* expected) {
    char* result = NULL;
    misaki_g2p_qya_convert(input, &result);
    
    if (strcmp(result, expected) == 0) {
        printf("✓ PASS: %s\n", name);
    } else {
        printf("✗ FAIL: %s\n", name);
        printf("  Expected: %s\n", expected);
        printf("  Got: %s\n", result);
    }
    free(result);
}

int main() {
    test_case("Short vowels", "aeiou", "a ɛ i ɔ u");
    test_case("Long vowels", "á", "aː");
    test_case("Quenya word", "quenya", "kw ɛ n j a");
    // ...
}
```

### 5.2 编译测试

```bash
# WSL2 中编译
cd /mnt/e/development/kokoro-ja-demo/misaki_c_port
mkdir -p build && cd build
cmake ..
make test_g2p_qya test_tokenizer_qya

# 运行测试
./test_g2p_qya
./test_tokenizer_qya
```

### 5.3 编译 Windows DLL

```bash
# 创建专用构建目录
cd /mnt/e/development/kokoro-ja-demo/misaki_c_port
mkdir -p build_quenya && cd build_quenya

# 配置并编译
cmake .. \
  -DCMAKE_SYSTEM_NAME=Windows \
  -DCMAKE_C_COMPILER=x86_64-w64-mingw32-gcc \
  -DBUILD_SHARED_LIBS=ON \
  -DCMAKE_BUILD_TYPE=Release

make misaki_shared -j4

# 复制 DLL 到发布目录
cp libmisaki.dll ../build_windows/
```

### 5.4 创建 Python 测试脚本

创建 `test_<language>_tts.py` 测试完整 TTS 流程：

```python
class MisakiCG2P:
    def __init__(self, dll_path=None, data_dir=None, force_lang='qya'):
        # 加载 DLL
        self.lib = ctypes.CDLL(str(dll_path))
        self.force_lang = force_lang
        # 初始化
        self.lib.misaki_init(data_dir.encode('utf-8'))
    
    def text_to_phonemes(self, text):
        output_buffer = ctypes.create_string_buffer(2048)
        result = self.lib.misaki_text_to_phonemes_lang(
            text.encode('utf-8'),
            self.force_lang.encode('utf-8'),
            output_buffer,
            len(output_buffer)
        )
        return output_buffer.value.decode('utf-8')

# 使用示例
g2p = MisakiCG2P(force_lang='qya')
phonemes = g2p.text_to_phonemes("Elen síla lúmenn' omentielvo")
print(f"IPA: /{phonemes}/")

# 调用 ONNX TTS 生成音频
audio = synthesize_with_phonemes(phonemes, voice='af_sarah')
sf.write('output.wav', audio, 24000)
```

### 5.5 运行完整测试

```bash
# 使用虚拟环境运行
cd E:\development\kokoro-ja-demo
e:/development/kokoro-ja-demo/.venv/Scripts/python.exe \
  misaki_c_port/build_quenya_test/test_quenya_tts.py "Quenya"
```

---

## 关键注意事项

### ✅ 必须做的事

1. **UTF-8 编码支持** - 所有源文件必须保存为 UTF-8
2. **音素映射表按长度排序** - 长的组合优先匹配（如 "qu" 优先于 "q"）
3. **内存管理** - 所有 malloc 的内存必须 free
4. **错误处理** - 检查空指针和边界条件
5. **测试覆盖** - 至少测试：元音、辅音、特殊字符、完整单词

### ❌ 常见陷阱

1. **忘记处理特殊字符** - 确保支持 UTF-8 多字节字符
2. **重音标记位置错误** - 重音符应该在音节开头
3. **映射表顺序错误** - 必须先匹配长组合再匹配短的
4. **忘记清理资源** - 在 cleanup 函数中释放所有资源
5. **未更新 CMakeLists.txt** - 新文件不会被编译

---

## 文件清单总结

添加一种新语言需要创建/修改以下文件：

### 新增文件（以昆雅语为例）

```
include/
  ├── misaki_g2p_qya.h           # G2P 头文件
  └── misaki_tokenizer_qya.h     # 分词器头文件

src/core/
  ├── misaki_g2p_qya.c           # G2P 实现
  └── misaki_tokenizer_qya.c     # 分词器实现

tests/
  ├── test_g2p_qya.c             # G2P 单元测试
  └── test_tokenizer_qya.c       # 分词器单元测试

docs/
  └── QUENYA_SUPPORT.md          # 语言特定文档（可选）
```

### 需要修改的文件

```
include/misaki_types.h           # 添加语言枚举
src/core/misaki_lang_detect.c    # 添加语言检测
src/api/misaki_api.c             # 集成 API
CMakeLists.txt                   # 添加编译配置
```

---

## 实际案例：昆雅语实现统计

**代码量统计：**
- 新增源文件：4 个（~900 行代码）
- 修改现有文件：4 个（~50 行增量）
- 测试文件：2 个（~230 行）
- 文档：2 个（~600 行）

**实现时间：** 约 1-2 小时

**测试结果：**
- 分词器：10/10 测试通过 ✓
- G2P 转换：24/33 测试通过（72.7%）
- TTS 合成：成功生成音频 ✓

---

## 下一步扩展

添加更多语言的建议：

1. **辛达林（Sindarin）** - 另一种托尔金精灵语
2. **克林贡语（Klingon）** - 星际迷航宇宙语言
3. **多斯拉克语（Dothraki）** - 权力的游戏语言
4. **纳威语（Na'vi）** - 阿凡达语言
5. **世界语（Esperanto）** - 国际辅助语

---

## 总结

添加新语言支持的核心是：

1. **研究音系** → 收集权威规则
2. **实现 G2P** → 字母到音素映射
3. **创建分词器** → 文本切分（如需要）
4. **集成系统** → 修改类型、检测、API
5. **测试验证** → 单元测试 + TTS 测试

整个过程模块化、可复用，新语言的添加不会影响现有语言功能。

---

**作者：** Misaki C Port 项目组  
**日期：** 2025-10-27  
**版本：** 1.0
